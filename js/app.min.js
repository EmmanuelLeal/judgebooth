var boothApp,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

boothApp = angular.module('judgebooth', ['ionic', 'angular-cache', 'pascalprecht.translate', 'judgebooth.services', 'judgebooth.controllers', 'judgebooth.translations']);

boothApp.config([
  '$locationProvider', '$stateProvider', '$urlRouterProvider', function($locationProvider, $stateProvider, $urlRouterProvider) {
    $locationProvider.html5Mode(!ionic.Platform.isWebView());
    $stateProvider.state('app', {
      url: '',
      abstract: true,
      templateUrl: 'views/menu.html',
      controller: 'SideCtrl'
    }).state('app.home', {
      url: '/',
      views: {
        menuContent: {
          templateUrl: 'views/home.html',
          controller: 'HomeCtrl'
        }
      }
    }).state('app.question', {
      url: '/question/:id',
      views: {
        menuContent: {
          templateUrl: 'views/question.html',
          controller: 'QuestionCtrl'
        }
      }
    });
    return $urlRouterProvider.otherwise('/');
  }
]);

boothApp.config([
  '$translateProvider', function($translateProvider) {
    var availableLanguages, language, navigatorLanguage;
    availableLanguages = ["en", "ru", "cn", "tw", "fr"];
    navigatorLanguage = navigator.language || navigator.userLanguage;
    navigatorLanguage = navigatorLanguage.replace(/^zh_/i, '').toLowerCase().substr(0, 2);
    language = "en";
    if (indexOf.call(availableLanguages, navigatorLanguage) >= 0) {
      language = navigatorLanguage;
    }
    $translateProvider.useSanitizeValueStrategy('escaped');
    return $translateProvider.registerAvailableLanguageKeys(availableLanguages).preferredLanguage(language).fallbackLanguage('en');
  }
]);

boothApp.run([
  'questionsAPI', '$rootScope', '$state', '$ionicPlatform', '$window', function(questionsAPI, $rootScope, $state, $ionicPlatform, $window) {
    $rootScope.$on('$stateChangeSuccess', function(event, toState) {
      return $rootScope.state = toState;
    });
    $rootScope.next = function() {
      return questionsAPI.nextQuestion().then(function(id) {
        return $state.go("app.question", {
          id: id
        });
      });
    };
    return $ionicPlatform.ready(function() {
      var appCache;
      $rootScope.online = navigator.onLine;
      appCache = $window.applicationCache;
      appCache.addEventListener('progress', function() {
        return $rootScope.cacheStatus = appCache.status;
      });
      appCache.addEventListener('error', function() {
        return $rootScope.$apply(function() {
          return $rootScope.cacheStatus = appCache.status;
        });
      });
      appCache.addEventListener('cached', function() {
        return $rootScope.$apply(function() {
          return $rootScope.cacheStatus = appCache.status;
        });
      });
      appCache.addEventListener('updateready', function() {
        return $rootScope.$apply(function() {
          return $rootScope.cacheStatus = appCache.status;
        });
      });
      return appCache.addEventListener('noupdate', function() {
        return $rootScope.$apply(function() {
          return $rootScope.cacheStatus = appCache.status;
        });
      });
    });
  }
]);

boothApp.directive('ngLoad', [
  '$parse', function($parse) {
    return {
      restrict: 'A',
      compile: function($element, attr) {
        var fn;
        fn = $parse(attr['ngLoad']);
        return function(scope, element, attr) {
          return element.on('load', function(event) {
            return scope.$apply(function() {
              return fn(scope, {
                $event: event
              });
            });
          });
        };
      }
    };
  }
]);

var controllers,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

controllers = angular.module("judgebooth.controllers", []);

controllers.controller('SideCtrl', [
  "$scope", "questionsAPI", "$ionicScrollDelegate", function($scope, questionsAPI, $ionicScrollDelegate) {
    $scope.filter = questionsAPI.filter();
    $scope.languages = questionsAPI.languages();
    $scope.languageCounts = {};
    questionsAPI.sets().then(function(response) {
      return $scope.sets = response.data;
    });
    questionsAPI.questions().then(function(response) {
      var base, base1, base2, card, i, j, k, l, language, len, len1, len2, len3, len4, m, question, ref, ref1, ref2, set, sets;
      $scope.questions = response.data;
      $scope.setCounts = {};
      ref = $scope.questions;
      for (i = 0, len = ref.length; i < len; i++) {
        question = ref[i];
        sets = [];
        ref1 = question.cards;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          card = ref1[j];
          for (k = 0, len2 = card.length; k < len2; k++) {
            set = card[k];
            if (indexOf.call(sets, set) < 0) {
              sets.push(set);
            }
          }
        }
        ref2 = question.languages;
        for (l = 0, len3 = ref2.length; l < len3; l++) {
          language = ref2[l];
          (base = $scope.languageCounts)[language] || (base[language] = 0);
          $scope.languageCounts[language]++;
          for (m = 0, len4 = sets.length; m < len4; m++) {
            set = sets[m];
            (base1 = $scope.setCounts)[language] || (base1[language] = {});
            (base2 = $scope.setCounts[language])[set] || (base2[set] = 0);
            $scope.setCounts[language][set]++;
          }
        }
      }
      return $scope.updateCount();
    });
    $scope.showSets = function() {
      $scope.setsShown = !$scope.setsShown;
      return $ionicScrollDelegate.resize();
    };
    $scope.toggleSet = function(id) {
      var i, j, k, len, len1, len2, ref, ref1, ref2, set;
      if (id === "all" || id === "modern" || id === "standard" || id === "none") {
        $scope.filter.sets = [];
      }
      switch (id) {
        case "standard":
          ref = $scope.sets;
          for (i = 0, len = ref.length; i < len; i++) {
            set = ref[i];
            if (!set.standard) {
              $scope.filter.sets.push(set.id);
            }
          }
          break;
        case "modern":
          ref1 = $scope.sets;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            set = ref1[j];
            if (!set.modern) {
              $scope.filter.sets.push(set.id);
            }
          }
          break;
        case "none":
          ref2 = $scope.sets;
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            set = ref2[k];
            $scope.filter.sets.push(set.id);
          }
          break;
        default:
          if (indexOf.call($scope.filter.sets, id) >= 0) {
            $scope.filter.sets.splice($scope.filter.sets.indexOf(id), 1);
          } else {
            $scope.filter.sets.push(id);
          }
      }
      return $scope.updateCount();
    };
    $scope.toggleDifficulty = function(level) {
      if (indexOf.call($scope.filter.difficulty, level) >= 0) {
        $scope.filter.difficulty.splice($scope.filter.difficulty.indexOf(level), 1);
      } else {
        $scope.filter.difficulty.push(level);
      }
      return $scope.updateCount();
    };
    $scope.updateCount = function() {
      var i, len, ref, results, set;
      questionsAPI.filterQuestions($scope.filter, false).then(function(questions) {
        return $scope.filteredQuestions = questions;
      });
      $scope.setCount = Object.keys($scope.setCounts[$scope.filter.language]).length;
      ref = $scope.filter.sets;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        set = ref[i];
        if ($scope.setCounts[$scope.filter.language][set]) {
          results.push($scope.setCount--);
        }
      }
      return results;
    };
    return $scope.showQuestions = function() {
      if (!$scope.filteredQuestions.length) {
        return;
      }
      questionsAPI.filter($scope.filter);
      return $scope.next();
    };
  }
]);

controllers.controller('HomeCtrl', [
  "$scope", "questionsAPI", function($scope, questionsAPI) {
    $scope.sets = [];
    $scope.languages = [];
    $scope.authors = [];
    $scope.questions = [];
    $scope.filtered = [];
    return $scope.$on("$ionicView.enter", function() {
      return questionsAPI.questions().then(function(response) {
        var card, i, j, k, language, len, len1, len2, question, ref, ref1, ref2, results, set;
        $scope.questions = response.data;
        questionsAPI.filterQuestions().then(function(questions) {
          return $scope.filtered = questions;
        });
        ref = $scope.questions;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          question = ref[i];
          if (ref1 = question.author, indexOf.call($scope.authors, ref1) < 0) {
            $scope.authors.push(question.author);
          }
          ref2 = question.cards;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            card = ref2[j];
            for (k = 0, len2 = card.length; k < len2; k++) {
              set = card[k];
              if (indexOf.call($scope.sets, set) < 0) {
                $scope.sets.push(set);
              }
            }
          }
          results.push((function() {
            var l, len3, ref3, results1;
            ref3 = question.languages;
            results1 = [];
            for (l = 0, len3 = ref3.length; l < len3; l++) {
              language = ref3[l];
              if (indexOf.call($scope.languages, language) < 0) {
                results1.push($scope.languages.push(language));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          })());
        }
        return results;
      });
    });
  }
]);

controllers.controller('QuestionCtrl', [
  "$scope", "questionsAPI", "$stateParams", "$state", "$ionicScrollDelegate", function($scope, questionsAPI, $stateParams, $state, $ionicScrollDelegate) {
    var gatherer;
    gatherer = 'http://gatherer.wizards.com/Handlers/Image.ashx?type=card&name=';
    questionsAPI.question($stateParams.id).then(function(question) {
      var card, i, len, ref, ref1;
      $scope.question = question;
      ref = question.cards;
      for (i = 0, len = ref.length; i < len; i++) {
        card = ref[i];
        card.src = gatherer + card.name;
        if (card.layout === "split") {
          card.src = gatherer + card.full_name;
        }
        if (card.url) {
          card.src = card.url;
        }
        card.manacost = (card.manacost || "").replace(/\{([wubrgx0-9]+)\}/ig, function(a, b) {
          return "<i class='mtg mana-" + (b.toLowerCase()) + "'></i>";
        }).replace(/\{([2wubrg])\/([wubrg])\}/ig, function(a, b, c) {
          return "<i class='mtg hybrid-" + ((b + c).toLowerCase()) + "'></i>";
        });
        card.text = (card.text || "").replace(/\{([wubrgx0-9]+)\}/ig, function(a, b) {
          return "<i class='mtg mana-" + (b.toLowerCase()) + "'></i>";
        }).replace(/\{t\}/ig, "<i class='mtg tap'></i>").replace(/\{q\}/ig, "<i class='mtg untap'></i>").replace(/\{([2wubrg])\/([wubrg])\}/ig, function(a, b, c) {
          return "<i class='mtg hybrid-" + ((b + c).toLowerCase()) + "'></i>";
        }).replace(/(\(.*?\))/ig, '<em>$1</em>');
        question.question = question.question.replace(RegExp("(" + card.name + ")", "ig"), "<b>$1</b>");
        question.answer = question.answer.replace(RegExp("(" + card.name + ")", "ig"), "<b>$1</b>");
      }
      if (!((ref1 = question.metadata) != null ? ref1.id : void 0)) {
        return $state.go("home");
      }
    });
    return $scope.toggleAnswer = function() {
      $scope.answer = !$scope.answer;
      $ionicScrollDelegate.resize();
      return $ionicScrollDelegate.scrollBottom(true);
    };
  }
]);

var services,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

services = angular.module("judgebooth.services", []);

services.service('questionsAPI', [
  "$http", "CacheFactory", "$q", "$translate", function($http, CacheFactory, $q, $translate) {
    var apiURL, availableLanguages, caches, k, language, len;
    caches = {
      persistent: CacheFactory('persistentCache', {
        storageMode: 'localStorage'
      }),
      short: CacheFactory('shortCache', {
        maxAge: 24 * 3600 * 1000,
        storageMode: 'localStorage'
      }),
      memory: CacheFactory('memoryCache', {
        maxAge: 3600 * 1000,
        capacity: 20
      })
    };
    availableLanguages = [
      {
        id: 1,
        name: "English",
        code: "en"
      }, {
        id: 2,
        name: "German",
        code: "de"
      }, {
        id: 3,
        name: "Italian",
        code: "it"
      }, {
        id: 4,
        name: "Japanese",
        code: "jp"
      }, {
        id: 5,
        name: "Korean",
        code: "ko"
      }, {
        id: 6,
        name: "Portuguese (Brazil)",
        code: "pt"
      }, {
        id: 7,
        name: "Russian",
        code: "ru"
      }, {
        id: 8,
        name: "Spanish",
        code: "es"
      }, {
        id: 9,
        name: "Chinese Simplified",
        code: "cn"
      }, {
        id: 10,
        name: "Chinese Traditional",
        code: "tw"
      }, {
        id: 11,
        name: "French",
        code: "fr"
      }
    ];
    apiURL = "http://" + window.location.host + "/backend/?action=";
    if (caches.persistent.get("filter")) {
      for (k = 0, len = availableLanguages.length; k < len; k++) {
        language = availableLanguages[k];
        if (!(language.id === parseInt(caches.persistent.get("filter").language, 10))) {
          continue;
        }
        $translate.use(language.code);
        break;
      }
    }
    return {
      sets: function() {
        return $http.get(apiURL + "sets", {
          cache: caches.short
        });
      },
      languages: function() {
        return availableLanguages;
      },
      questions: function() {
        return $http.get(apiURL + "questions", {
          cache: caches.short
        });
      },
      question: function(id) {
        var deferred, questionPromise;
        deferred = $q.defer();
        language = this.filter().language;
        if (!navigator.onLine) {
          questionPromise = $http.get(apiURL + "question&lang=" + language + "&id=" + id, {
            cache: caches.memory
          });
          $q.all([this.questions(), questionPromise]).then(function(arg) {
            var l, len1, metadata, question, questionResponse, questionsResponse, ref;
            questionsResponse = arg[0], questionResponse = arg[1];
            question = questionResponse.data;
            ref = questionsResponse.data;
            for (l = 0, len1 = ref.length; l < len1; l++) {
              metadata = ref[l];
              if (metadata.id === parseInt(id, 10)) {
                question.metadata = metadata;
              }
            }
            return deferred.resolve(question);
          }, function() {
            return deferred.reject();
          });
        } else {
          questionPromise = $http.get(apiURL + "offline", {
            cache: caches.memory
          });
          $q.all([this.questions(), questionPromise]).then(function(arg) {
            var card, cardId, l, len1, len2, m, metadata, question, questionResponse, questionsResponse, ref, ref1, ref2;
            questionsResponse = arg[0], questionResponse = arg[1];
            if (questionResponse.data.questions[id]) {
              question = questionResponse.data.questions[id][language] || questionResponse.data.questions[id][1];
              question.cards = [];
              ref = questionResponse.data.questions[id].cards;
              for (l = 0, len1 = ref.length; l < len1; l++) {
                cardId = ref[l];
                card = questionResponse.data.cards[cardId];
                card.name_en = card.name;
                if ((ref1 = card.translations) != null ? ref1[language] : void 0) {
                  card.name = card.translations[language];
                }
                question.cards.push(card);
              }
              ref2 = questionsResponse.data;
              for (m = 0, len2 = ref2.length; m < len2; m++) {
                metadata = ref2[m];
                if (metadata.id === parseInt(id, 10)) {
                  question.metadata = metadata;
                }
              }
              return deferred.resolve(question);
            } else {
              return deferred.reject();
            }
          }, function() {
            return deferred.reject();
          });
        }
        return deferred.promise;
      },
      filter: function(filter) {
        var currentLanguage, filterDefault, l, len1, len2, m, ref;
        ref = this.languages();
        for (l = 0, len1 = ref.length; l < len1; l++) {
          language = ref[l];
          if (language.code === $translate.use()) {
            currentLanguage = language.id;
          }
        }
        filterDefault = {
          language: currentLanguage,
          sets: [],
          difficulty: []
        };
        if (filter != null) {
          console.log("filter set", filter);
          for (m = 0, len2 = availableLanguages.length; m < len2; m++) {
            language = availableLanguages[m];
            if (!(language.id === parseInt(filter.language, 10))) {
              continue;
            }
            console.log("use", language.code);
            $translate.use(language.code);
          }
          caches.persistent.put("filter", filter);
          caches.memory.remove("filteredQuestions");
        }
        return caches.persistent.get("filter") || filterDefault;
      },
      filterQuestions: function(filter, useCache) {
        var deferred;
        if (useCache == null) {
          useCache = true;
        }
        deferred = $q.defer();
        if (useCache && caches.memory.get("filteredQuestions")) {
          deferred.resolve(caches.memory.get("filteredQuestions"));
        } else {
          filter || (filter = this.filter());
          this.questions().then(function(response) {
            var card, filteredQuestions, hasIllegalCard, i, isLegalCard, j, l, len1, len2, len3, m, n, question, questions, ref, ref1, ref2, set, t;
            questions = response.data;
            filteredQuestions = [];
            for (l = 0, len1 = questions.length; l < len1; l++) {
              question = questions[l];
              if (ref = parseInt(filter.language, 10), indexOf.call(question.languages, ref) < 0) {
                continue;
              }
              if (filter.difficulty.length && (ref1 = question.difficulty, indexOf.call(filter.difficulty, ref1) >= 0)) {
                continue;
              }
              if (filter.sets.length) {
                hasIllegalCard = false;
                ref2 = question.cards;
                for (m = 0, len2 = ref2.length; m < len2; m++) {
                  card = ref2[m];
                  isLegalCard = false;
                  for (n = 0, len3 = card.length; n < len3; n++) {
                    set = card[n];
                    if (indexOf.call(filter.sets, set) < 0) {
                      isLegalCard = true;
                    }
                  }
                  hasIllegalCard = !isLegalCard;
                  if (hasIllegalCard) {
                    break;
                  }
                }
                if (hasIllegalCard) {
                  continue;
                }
              }
              filteredQuestions.push(question.id);
            }
            i = filteredQuestions.length;
            while (--i > 0) {
              j = ~~(Math.random() * (i + 1));
              t = filteredQuestions[j];
              filteredQuestions[j] = filteredQuestions[i];
              filteredQuestions[i] = t;
            }
            if (useCache) {
              caches.memory.put("filteredQuestions", filteredQuestions);
            }
            return deferred.resolve(filteredQuestions);
          }, function() {
            return deferred.reject();
          });
        }
        return deferred.promise;
      },
      nextQuestion: function() {
        var deferred;
        deferred = $q.defer();
        this.filterQuestions().then(function(questions) {
          questions.push(questions.shift());
          caches.memory.put("filteredQuestions", questions);
          return deferred.resolve(questions[0]);
        }, function() {
          return deferred.reject();
        });
        return deferred.promise;
      }
    };
  }
]);
